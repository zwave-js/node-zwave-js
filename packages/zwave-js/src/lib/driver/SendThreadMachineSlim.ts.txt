import { type ZWaveError } from "@zwave-js/core";
import { type Message } from "@zwave-js/serial";
import { getErrorMessage } from "@zwave-js/shared";
import { assign, createMachine, forwardTo, type InterpreterFrom } from "xstate";
import { type DriverLogger } from "../log/Driver";
import {
	createSerialAPICommandMachine,
	type SerialAPICommandError,
	type SerialAPICommandMachineParams,
} from "./SerialAPICommandMachine";
import {
	createMessageDroppedUnexpectedError,
	sendDataErrorToZWaveError,
} from "./StateMachineShared";
import { type Transaction } from "./Transaction";

export interface ServiceImplementations {
	pollQueue: (prevResult: Message | ZWaveError | undefined) => Promise<
		| {
				transaction: Transaction;
				message: Message;
		  }
		| undefined
	>;
	notifyUnsolicited: (message: Message) => void;
	sendData: (data: Buffer) => Promise<void>;
	// createSendDataAbort: () => SendDataAbort;
	notifyRetry?: (
		command: "SendData" | "SerialAPI",
		lastError: SerialAPICommandError | undefined,
		message: Message,
		attempts: number,
		maxAttempts: number,
		delay: number,
	) => void;
	timestamp: () => number;
	logOutgoingMessage: (message: Message) => void;
	log: DriverLogger["print"];
}

export type SendThreadSlimMachineParams = SerialAPICommandMachineParams;

interface SendThreadSlimContext {
	transaction?: Transaction;
	message?: Message;
	result?: Message;
	error?: ZWaveError;
}

export type SendThreadSlimEvents =
	// Tell the machine to poll the queue again if it was idle
	| { type: "trigger" }
	// These events are forwarded to the SerialAPICommand machine
	| { type: "ACK" }
	| { type: "CAN" }
	| { type: "NAK" }
	// Used for received messages. The message will be returned as unsolicited when it is not expected
	| { type: "message"; message: Message }
	| { type: "unsolicited"; message: Message };

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function createSendThreadMachineSlim(
	implementations: ServiceImplementations,
	params: SendThreadSlimMachineParams,
) {
	const ret = createMachine<SendThreadSlimContext, SendThreadSlimEvents>(
		{
			predictableActionArguments: true,
			context: {
				transaction: undefined,
				message: undefined,
				result: undefined,
				error: undefined,
			},
			initial: "idle",
			states: {
				idle: {
					// Only leave the idle state when triggered
					on: {
						trigger: "nextMessage",
					},
				},
				nextMessage: {
					invoke: {
						// nextMessage will generate a new message to send until the queue is empty
						id: "nextMessage",
						src: "nextMessage",
						onDone: [
							{
								// If we got a message, store it and transition to sending
								cond: "hasMessage",
								actions: assign((_, evt) => ({
									message: evt.data.message,
									transaction: evt.data.transaction,
								})),
								target: "sending",
							},
							// If the queue is empty, go back to the idle state
							{ target: "idle" },
						],
						// If the next message cannot be generated because of an error, the transaction is also done
						onError: { target: "done" },
					},
				},
				execute: {
					invoke: {
						id: "execute",
						src: "executeSerialAPICommand",
						onDone: [
							{
								cond: "executeSuccessful",
								target: "executeDone",
								actions: "rememberCommandSuccess",
							},
							{
								target: "executeDone",
								actions: "rememberCommandFailure",
							},
						],
						onError: {
							target: "executeDone",
							actions: "rememberCommandError",
						},
					},
				},
				abortSendData: {
					invoke: {
						id: "executeSendDataAbort",
						src: "executeSendDataAbort",
						onDone: "executeDone",
					},
				},
				executeDone: {
					always: {
						target: "idle",
						actions: "unsetMessage",
					},
				},
			},

			on: {
				// When a serial API machine is active, forward the message. Otherwise, return all messages as unsolicited.
				message: [
					{
						cond: "isExecuting",
						actions: forwardTo("execute"),
					},
					{ actions: "notifyUnsolicited" },
				],
				unsolicited: [
					// The Serial API has determined this message to be unsolicited
					// Forward it to the SendThreadMachine
					{ actions: "notifyUnsolicited" },
				],

				// Forward low-level messages to the serial API command machine
				ACK: [
					// {
					// 	cond: "isAbortingWithTimeout",
					// 	actions: forwardTo("executeSendDataAbort"),
					// },
					{
						cond: "isExecuting",
						actions: forwardTo("execute"),
					},
				],
				CAN: [
					// {
					// 	cond: "isAbortingWithTimeout",
					// 	actions: forwardTo("executeSendDataAbort"),
					// },
					{
						cond: "isExecuting",
						actions: forwardTo("execute"),
					},
				],
				NAK: [
					// {
					// 	cond: "isAbortingWithTimeout",
					// 	actions: forwardTo("executeSendDataAbort"),
					// },
					{
						cond: "isExecuting",
						actions: forwardTo("execute"),
					},
				],
			},
		},
		{
			actions: {
				unsetMessage: assign({
					message: undefined,
					transaction: undefined,
				}),
				rememberCommandSuccess: assign((_, evt: any) => ({
					result: evt.result,
					error: undefined,
				})),
				rememberCommandFailure: assign((ctx, evt: any) => ({
					result: undefined,
					error: sendDataErrorToZWaveError(
						evt.reason,
						ctx.transaction!,
						evt.result,
					),
					// TODO: Do this in the driver
					// // For messages that were sent to a node, a NOK callback still contains useful info we need to evaluate
					// if (
					// 	(isSendData(ctx.transaction?.parts.current) ||
					// 		isTransmitReport(evt.result)) &&
					// 	evt.reason === "callback NOK"
					// ) {
					// 	return {
					// 		...ctx,
					// 		result: evt.result,
					// 		error: undefined,
					// 	};
					// } else {
					// 	return {
					// 		...ctx,
					// 		result: undefined,
					// 		error: sendDataErrorToZWaveError(
					// 			evt.reason,
					// 			ctx.transaction,
					// 			evt.result,
					// 		),
					// 	};
					// }
				})),
				rememberCommandError: assign((_, evt: any) => ({
					result: undefined,
					error: createMessageDroppedUnexpectedError(evt.error),
				})),
				unsetCommandResult: assign((_) => ({
					result: undefined,
					error: undefined,
				})),
				notifyUnsolicited: (_, evt: any) => {
					implementations.notifyUnsolicited(evt.message);
				},
			},
			guards: {
				executeSuccessful: (_, evt: any) =>
					evt.data?.type === "success",
				hasMessage: (ctx, evt: any) => !!evt.data,
				isExecuting: (ctx, evt, meta) => meta.state.matches("execute"),
			},
			services: {
				// This service polls the queue for the next message to send. It also passes the result of the last command
				// so the generator can decide whether to continue or not.
				nextMessage: (ctx) =>
					implementations.pollQueue(ctx.error ?? ctx.result),
				executeSerialAPICommand: (ctx) => {
					try {
						return createSerialAPICommandMachine(
							ctx.message!,
							implementations,
							params,
						);
					} catch (e) {
						// If there is an error while creating the command machine (e.g. during message serialization)
						// wrap it in a rejected promise, so xstate can handle it
						implementations.log(
							`Unexpected error during SerialAPI command: ${getErrorMessage(
								e,
								true,
							)}`,
							"error",
						);
						return Promise.reject(e);
					}
				},
				// executeSendDataAbort: (_) =>
				// 	createSerialAPICommandMachine(
				// 		implementations.createSendDataAbort(),
				// 		implementations,
				// 		params,
				// 	),
			},
		},
	);

	return ret;
}

export type SendThreadMachineSlim = ReturnType<
	typeof createSendThreadMachineSlim
>;

export type SendThreadSlimInterpreter = InterpreterFrom<SendThreadMachineSlim>;
