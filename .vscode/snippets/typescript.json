{
	"Z-Wave message classes": {
		"prefix": "zwmsg",
		"body": [
			"import { IDriver } from \"../driver/IDriver\";",
			"import { ZWaveError, ZWaveErrorCodes } from \"../error/ZWaveError\";",
			"import {",
			"\tFunctionType,",
			"\tMessagePriority,",
			"\tMessageType,",
			"} from \"../message/Constants\";",
			"import {",
			"\texpectedResponse,",
			"\tgotDeserializationOptions,",
			"\tMessage,",
			"\tMessageBaseOptions,",
			"\tMessageDeserializationOptions,",
			"\tmessageTypes,",
			"\tpriority,",
			"} from \"../message/Message\";",
			"",
			"export interface ${1}${2}Options extends MessageBaseOptions {",
			"\t${0:someProperty: number;}",
			"}",
			"",
			"@messageTypes(MessageType.${2}, FunctionType.${1})",
			"@expectedResponse(FunctionType.${1})",
			"@priority(MessagePriority.${3:Normal})",
			"export class ${1:Dummy}${2:Request} extends Message {",
			"\tpublic constructor(",
			"\t\tdriver: IDriver,",
			"\t\toptions: MessageDeserializationOptions | ${1}${2}Options,",
			"\t) {",
			"\t\tsuper(driver, options);",
			"\t\tif (gotDeserializationOptions(options)) {",
			"\t\t\tthrow new ZWaveError(",
			"\t\t\t\t`${this.constructor.name}: deserialization not implemented`,",
			"\t\t\t\tZWaveErrorCodes.Deserialization_NotImplemented,",
			"\t\t\t);",
			"\t\t} else {",
			"\t\t\t// TODO: Populate properties from options object",
			"\t\t\tthrow new Error(\"not implemented\");",
			"\t\t}",
			"\t}",
			"",
			"\tpublic serialize(): Buffer {",
			"\t\tthis.payload = Buffer.from([",
			"\t\t\t/* TODO: serialize */",
			"\t\t]);",
			"",
			"\t\treturn super.serialize();",
			"\t}",
			"}",
			""
		]
	},
	"Z-Wave message class test": {
		"prefix": "zwmsgtest",
		"body": [
			"describe(\"lib/${1:driver}/${2:Test}${3:Request} => \", () => {",
			"\tconst req = new ${2}${3}(undefined);",
			"",
			"\tit(\"should be a Message\", () => {",
			"\t\texpect(req).toBeInstanceOf(Message);",
			"\t});",
			"\tit(\"with type ${3}\", () => {",
			"\t\texpect(getMessageType(req)).toBe(MessageType.${3});",
			"\t\texpect(getMessageTypeStatic(${2}${3})).toBe(MessageType.${3});",
			"\t});",
			"\tit(\"and priority ${4:Normal}\", () => {",
			"\t\texpect(getDefaultPriority(req)).toBe(MessagePriority.${4});",
			"\t\texpect(getDefaultPriorityStatic(${2}${3})).toBe(MessagePriority.${4});",
			"\t});",
			"\tit(\"and a function type ${2}\", () => {",
			"\t\texpect(getFunctionType(req)).toBe(FunctionType.${2});",
			"\t\texpect(getFunctionTypeStatic(${2}${3})).toBe(FunctionType.${2});",
			"\t});",
			"\tit(\"that expects a ${2} response\", () => {",
			"\t\texpect(getExpectedResponse(req)).toBe(FunctionType.${2});",
			"\t\texpect(getExpectedResponseStatic(${2}${3})).toBe(FunctionType.${2});",
			"\t});",
			"",
			"});"
		]
	},
	"Z-Wave toJSON override": {
		"prefix": "zwjson",
		"body": [
			"public toJSON(): JSONObject {",
			"\treturn super.toJSONInherited({",
			"\t\t${0}",
			"\t});",
			"}"
		]
	},
	"Z-Wave Command Class implementation": {
		"prefix": "zwcc",
		"body": [
			"import {",
			"\tCCCommand,",
			"\tCCCommandOptions,",
			"\tCommandClass,",
			"\tcommandClass,",
			"\texpectedCCResponse,",
			"\timplementedVersion,",
			"\tCommandClassDeserializationOptions,",
			"\tgotDeserializationOptions,",
			"} from \"./CommandClass\";",
			"import { CommandClasses } from \"./CommandClasses\";",
			"import { IDriver } from \"../driver/IDriver\";",
			"",
			"// All the supported commands",
			"export enum ${1:Basic}Command {",
			"\t${3:// Get = 0x01}",
			"}",
			"",
			"export interface ${1}CC {",
			"\tccCommand: ${1}Command;",
			"}",
			"",
			"@commandClass(CommandClasses.${1})",
			"@implementedVersion(${2:1})",
			"export class ${1}CC extends CommandClass {}",
			"",
			"${0}"
		],
		"description": "Z-Wave Command Class implementation"
	},
	"Z-Wave CC Command": {
		"prefix": "zwcccmd",
		"body": [
			"interface ${1:Basic}CC${2:Get}Options extends CCCommandOptions {",
			"\tsomeProperty: number;",
			"}",
			"",
			"@CCCommand(${1}Command.${2})",
			"@expectedCCResponse(${1}CCReport)",
			"export class ${1}CC${2} extends ${1}CC {",
			"\tpublic constructor(",
			"\t\tdriver: IDriver,",
			"\t\toptions: CommandClassDeserializationOptions | ${1}CC${2}Options,",
			"\t) {",
			"\t\tsuper(driver, options);",
			"\t\tif (gotDeserializationOptions(options)) {",
			"\t\t\t// TODO: Deserialize payload",
			"\t\t\tthrow new ZWaveError(",
			"\t\t\t\t`${this.constructor.name}: deserialization not implemented`,",
			"\t\t\t\tZWaveErrorCodes.Deserialization_NotImplemented,",
			"\t\t\t);",
			"\t\t} else {",
			"\t\t\t// TODO: Populate properties from options object",
			"\t\t\tthrow new Error(\"not implemented\");",
			"\t\t}",
			"\t}",
			"",
			"\tpublic serialize(): Buffer {",
			"\t\tthis.payload = Buffer.from([",
			"\t\t\t/* TODO: serialize */",
			"\t\t]);",
			"\t\treturn super.serialize();",
			"\t}",
			"}",
			"${0}"
		],
		"description": "Specific implementation of a single CC command"
	},
	"Z-Wave CC Command (Report)": {
		"prefix": "zwccreport",
		"body": [
			"@CCCommand(${1:Basic}Command.${2}Report)",
			"export class ${1}CC${2}Report extends ${1}CC {",
			"\tpublic constructor(",
			"\t\tdriver: IDriver,",
			"\t\toptions: CommandClassDeserializationOptions,",
			"\t) {",
			"\t\tsuper(driver, options);",
			"\t\t${0:// TODO: Deserialize}",
			"\t}",
			"}"
		],
		"description": "Specific implementation of a single CC report"
	},
	"ZWave CC Command (empty)": {
		"prefix": "zwccemptycmd",
		"body": [
			"@CCCommand(${1:Basic}Command.${2:Get})",
			"export class ${1}CC${2} extends ${1}CC {",
			"\tpublic constructor(",
			"\t\tdriver: IDriver,",
			"\t\toptions: CommandClassDeserializationOptions | CCCommandOptions,",
			"\t) {",
			"\t\tsuper(driver, options);",
			"\t}",
			"}"
		],
		"description": "Specific implementation of CC command that is sent and expects no parameters"
	},
	"Readonly property": {
		"prefix": "propread",
		"body": [
			"private _${1:value}: ${2:string};",
			"public get ${1}(): ${2} {",
			"\treturn this._${1};",
			"}${0}"
		]
	},
	"Z-Wave CC property": {
		"prefix": "zwccprop",
		"body": ["@ccValue() public ${1:property}: ${2:number};${0}"]
	},
	"Z-Wave CC API": {
		"prefix": "zwccapi",
		"body": [
			"@API(CommandClasses.${1:Basic})",
			"export class ${1}CCAPI extends CCAPI {",
			"\t${0:// TODO: Implementation}",
			"}"
		]
	},
	"Z-Wave CC interview procedure": {
		"prefix": "zwccinterview",
		"body": [
			"public async interview(complete: boolean = true): Promise<void> {",
			"\tconst node = this.getNode()!;",
			"\tconst api = node.commandClasses.${1:Basic};",
			"",
			"\tlog.controller.logNode(node.id, {",
			"\t\tmessage: `${this.constructor.name}: doing a ${",
			"\t\t\tcomplete ? \"complete\" : \"partial\"",
			"\t\t} interview...`,",
			"\t\tdirection: \"none\",",
			"\t});",
			"",
			"\t// Always keep the node's time in sync",
			"\tlog.controller.logNode(node.id, {",
			"\t\tmessage: \"doing something...\",",
			"\t\tdirection: \"outbound\",",
			"\t});",
			"\t${0:// TODO: Implementation}",
			"\tconst logMessage = `received response for something...`;",
			"\tlog.controller.logNode(node.id, {",
			"\t\tmessage: logMessage,",
			"\t\tdirection: \"inbound\",",
			"\t});",
			"",
			"\t// Remember that the interview is complete",
			"\tthis.interviewComplete = true;",
			"}"
		]
	},
	"Z-Wave CC interview requirements": {
		"prefix": "zwccintreq",
		"body": [
			"public determineRequiredCCInterviews(): readonly CommandClasses[] {",
			"\treturn [",
			"\t\t...super.determineRequiredCCInterviews(),",
			"\t\tCommandClasses.${0:Basic},",
			"\t];",
			"}"
		]
	},
	"Jest test file": {
		"prefix": "jest",
		"body": [
			"/// <reference types=\"jest-extended\" />",
			"import { ${3:methodToTest} } from \"./${2}\";",
			"",
			"describe(\"${1:path}/${2:moduleToTest}\", () => {",
			"\tdescribe(\"${3}()\", () => {",
			"\t\tit(\"${4:does something}\", () => {",
			"\t\t\t${0:// implementation}",
			"\t\t});",
			"\t});",
			"});"
		]
	},
	"Z-Wave CC Test": {
		"prefix": "zwcctest",
		"body": [
			"import { createEmptyMockDriver } from \"../../../test/mocks\";",
			"import { IDriver } from \"../driver/IDriver\";",
			"import {",
			"\t${1}CC,",
			"\t${1}CCGet,",
			"\t${1}CCReport,",
			"\t${1}CCSet,",
			"\t${1}Command,",
			"} from \"./${1}CC\";",
			"import { getCCValueMetadata } from \"./CommandClass\";",
			"import { CommandClasses } from \"./CommandClasses\";",
			"",
			"const fakeDriver = (createEmptyMockDriver() as unknown) as IDriver;",
			"",
			"function buildCCBuffer(nodeId: number, payload: Buffer): Buffer {",
			"\treturn Buffer.concat([",
			"\t\tBuffer.from([",
			"\t\t\tnodeId, // node number",
			"\t\t\tpayload.length + 1, // remaining length",
			"\t\t\tCommandClasses.${1}, // CC",
			"\t\t]),",
			"\t\tpayload,",
			"\t]);",
			"}",
			"",
			"describe(\"lib/commandclass/${1:Basic}CC => \", () => {",
			"\tit(\"the Get command should serialize correctly\", () => {",
			"\t\tconst cc = new ${1}CCGet(fakeDriver, { nodeId: 1 });",
			"\t\tconst expected = buildCCBuffer(",
			"\t\t\t1,",
			"\t\t\tBuffer.from([",
			"\t\t\t\t${1}Command.Get, // CC Command",
			"\t\t\t]),",
			"\t\t);",
			"\t\texpect(cc.serialize()).toEqual(expected);",
			"\t});",
			"",
			"\tit(\"the Set command should serialize correctly\", () => {",
			"\t\tconst cc = new ${1}CCSet(fakeDriver, {",
			"\t\t\tnodeId: 2,",
			"\t\t\ttargetValue: 55,",
			"\t\t});",
			"\t\tconst expected = buildCCBuffer(",
			"\t\t\t2,",
			"\t\t\tBuffer.from([",
			"\t\t\t\t${1}Command.Set, // CC Command",
			"\t\t\t\t55, // target value",
			"\t\t\t]),",
			"\t\t);",
			"\t\texpect(cc.serialize()).toEqual(expected);",
			"\t});",
			"",
			"\tit(\"the Report command (v1) should be deserialized correctly\", () => {",
			"\t\tconst ccData = buildCCBuffer(",
			"\t\t\t1,",
			"\t\t\tBuffer.from([",
			"\t\t\t\t${1}Command.Report, // CC Command",
			"\t\t\t\t55, // current value",
			"\t\t\t]),",
			"\t\t);",
			"\t\tconst cc = new ${1}CCReport(fakeDriver, { data: ccData });",
			"",
			"\t\texpect(cc.currentValue).toBe(55);",
			"\t\texpect(cc.targetValue).toBeUndefined();",
			"\t\texpect(cc.duration).toBeUndefined();",
			"\t});",
			"",
			"\tit(\"the Report command (v2) should be deserialized correctly\", () => {",
			"\t\tconst ccData = buildCCBuffer(",
			"\t\t\t1,",
			"\t\t\tBuffer.from([",
			"\t\t\t\t${1}Command.Report, // CC Command",
			"\t\t\t\t55, // current value",
			"\t\t\t\t66, // target value",
			"\t\t\t\t1, // duration",
			"\t\t\t]),",
			"\t\t);",
			"\t\tconst cc = new ${1}CCReport(fakeDriver, { data: ccData });",
			"",
			"\t\texpect(cc.currentValue).toBe(55);",
			"\t\texpect(cc.targetValue).toBe(66);",
			"\t\texpect(cc.duration!.unit).toBe(\"seconds\");",
			"\t\texpect(cc.duration!.value).toBe(1);",
			"\t});",
			"",
			"\tit(\"deserializing an unsupported command should return an unspecified version of ${1}CC\", () => {",
			"\t\tconst serializedCC = buildCCBuffer(",
			"\t\t\t1,",
			"\t\t\tBuffer.from([255]), // not a valid command",
			"\t\t);",
			"\t\tconst cc: any = new ${1}CC(fakeDriver, {",
			"\t\t\tdata: serializedCC,",
			"\t\t});",
			"\t\texpect(cc.constructor).toBe(${1}CC);",
			"\t});",
			"",
			"\tit(\"the CC values should have the correct metadata\", () => {",
			"\t\t// Readonly, 0-99",
			"\t\tconst currentValueMeta = getCCValueMetadata(",
			"\t\t\tCommandClasses.${1},",
			"\t\t\t\"currentValue\",",
			"\t\t);",
			"\t\texpect(currentValueMeta).toMatchObject({",
			"\t\t\treadable: true,",
			"\t\t\twriteable: false,",
			"\t\t\tmin: 0,",
			"\t\t\tmax: 99,",
			"\t\t});",
			"",
			"\t\t// Writeable, 0-99",
			"\t\tconst targetValueMeta = getCCValueMetadata(",
			"\t\t\tCommandClasses.${1},",
			"\t\t\t\"targetValue\",",
			"\t\t);",
			"\t\texpect(targetValueMeta).toMatchObject({",
			"\t\t\treadable: true,",
			"\t\t\twriteable: true,",
			"\t\t\tmin: 0,",
			"\t\t\tmax: 99,",
			"\t\t});",
			"\t});",
			"});",
			""
		],
		"description": "Specific implementation of a single CC command"
	}
}
