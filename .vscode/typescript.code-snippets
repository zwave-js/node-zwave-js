{
	"Z-Wave Serial API command without response/callback": {
		"scope": "typescript",
		"prefix": "zwmsg",
		"body": [
			"import {",
			"\tMessageOrCCLogEntry,",
			"\tMessagePriority,",
			"\tZWaveError,",
			"\tZWaveErrorCodes,",
			"} from \"@zwave-js/core\";",
			"import type { ZWaveApplicationHost, ZWaveHost } from \"@zwave-js/host\";",
			"import {",
			"\tFunctionType,",
			"\tgotDeserializationOptions,",
			"\tMessage,",
			"\tMessageBaseOptions,",
			"\tMessageDeserializationOptions,",
			"\tMessageType,",
			"\tmessageTypes,",
			"\tpriority,",
			"} from \"@zwave-js/serial\";",
			"",
			"export interface ${1}RequestOptions extends MessageBaseOptions {",
			"\t${0:someProperty: number;}",
			"}",
			"",
			"@messageTypes(MessageType.Request, FunctionType.${1:Dummy})",
			"@priority(MessagePriority.${2:Normal})",
			"export class ${1}Request extends Message {",
			"\tpublic constructor(",
			"\t\thost: ZWaveHost,",
			"\t\toptions: MessageDeserializationOptions | ${1}RequestOptions,",
			"\t) {",
			"\t\tsuper(host, options);",
			"\t\tif (gotDeserializationOptions(options)) {",
			"\t\t\tthrow new ZWaveError(",
			"\t\t\t\t`${this.constructor.name}: deserialization not implemented`,",
			"\t\t\t\tZWaveErrorCodes.Deserialization_NotImplemented,",
			"\t\t\t);",
			"\t\t} else {",
			"\t\t\t// TODO: Populate properties from options object",
			"\t\t\tthrow new Error(\"not implemented\");",
			"\t\t}",
			"\t}",
			"",
			"\tpublic serialize(): Buffer {",
			"\t\tthis.payload = Buffer.from([",
			"\t\t\t/* TODO: serialize */",
			"\t\t]);",
			"",
			"\t\treturn super.serialize();",
			"\t}",
			"",
			"\tpublic toLogEntry(): MessageOrCCLogEntry {",
			"\t\treturn {",
			"\t\t\t...super.toLogEntry(),",
			"\t\t\tmessage: {",
			"\t\t\t\t\"some property\": 1,",
			"\t\t\t},",
			"\t\t};",
			"\t}",
			"}"
		]
	},
	"Z-Wave Serial API command with response": {
		"scope": "typescript",
		"prefix": "zwmsgres",
		"body": [
			"import {",
			"\tMessageOrCCLogEntry,",
			"\tMessagePriority,",
			"\tZWaveError,",
			"\tZWaveErrorCodes,",
			"} from \"@zwave-js/core\";",
			"import type { ZWaveApplicationHost, ZWaveHost } from \"@zwave-js/host\";",
			"import {",
			"\texpectedResponse,",
			"\tFunctionType,",
			"\tgotDeserializationOptions,",
			"\tMessage,",
			"\tMessageBaseOptions,",
			"\tMessageDeserializationOptions,",
			"\tMessageType,",
			"\tmessageTypes,",
			"\tpriority,",
			"\tSuccessIndicator,",
			"} from \"@zwave-js/serial\";",
			"",
			"export interface ${1}RequestOptions extends MessageBaseOptions {",
			"\t${0:someProperty: number;}",
			"}",
			"",
			"@messageTypes(MessageType.Request, FunctionType.${1:Dummy})",
			"@priority(MessagePriority.${2:Normal})",
			"@expectedResponse(FunctionType.${1})",
			"export class ${1}Request extends Message {",
			"\tpublic constructor(",
			"\t\thost: ZWaveHost,",
			"\t\toptions: MessageDeserializationOptions | ${1}RequestOptions,",
			"\t) {",
			"\t\tsuper(host, options);",
			"\t\tif (gotDeserializationOptions(options)) {",
			"\t\t\tthrow new ZWaveError(",
			"\t\t\t\t`${this.constructor.name}: deserialization not implemented`,",
			"\t\t\t\tZWaveErrorCodes.Deserialization_NotImplemented,",
			"\t\t\t);",
			"\t\t} else {",
			"\t\t\t// TODO: Populate properties from options object",
			"\t\t\tthrow new Error(\"not implemented\");",
			"\t\t}",
			"\t}",
			"",
			"\tpublic serialize(): Buffer {",
			"\t\tthis.payload = Buffer.from([",
			"\t\t\t/* TODO: serialize */",
			"\t\t]);",
			"",
			"\t\treturn super.serialize();",
			"\t}",
			"",
			"\tpublic toLogEntry(): MessageOrCCLogEntry {",
			"\t\treturn {",
			"\t\t\t...super.toLogEntry(),",
			"\t\t\tmessage: {",
			"\t\t\t\t\"some property\": 1,",
			"\t\t\t},",
			"\t\t};",
			"\t}",
			"}",
			"",
			"@messageTypes(MessageType.Response, FunctionType.${1})",
			"export class ${1}Response extends Message implements SuccessIndicator {",
			"\tpublic constructor(host: ZWaveHost, options: MessageDeserializationOptions) {",
			"\t\tsuper(host, options);",
			"\t\tthis.wasSent = this.payload[0] !== 0;",
			"\t}",
			"",
			"\tisOK(): boolean {",
			"\t\treturn this.wasSent;",
			"\t}",
			"",
			"\tpublic readonly wasSent: boolean;",
			"",
			"\tpublic toLogEntry(): MessageOrCCLogEntry {",
			"\t\treturn {",
			"\t\t\t...super.toLogEntry(),",
			"\t\t\tmessage: { \"was sent\": this.wasSent },",
			"\t\t};",
			"\t}",
			"}"
		]
	},
	"Z-Wave Serial API command with response and callback": {
		"scope": "typescript",
		"prefix": "zwmsgrescb",
		"body": [
			"import {",
			"\tMessageOrCCLogEntry,",
			"\tMessagePriority,",
			"\tZWaveError,",
			"\tZWaveErrorCodes,",
			"} from \"@zwave-js/core\";",
			"import type { ZWaveApplicationHost, ZWaveHost } from \"@zwave-js/host\";",
			"import {",
			"\texpectedCallback,",
			"\texpectedResponse,",
			"\tFunctionType,",
			"\tgotDeserializationOptions,",
			"\tMessage,",
			"\tMessageBaseOptions,",
			"\tMessageDeserializationOptions,",
			"\tMessageOptions,",
			"\tMessageType,",
			"\tmessageTypes,",
			"\tpriority,",
			"\tSuccessIndicator,",
			"} from \"@zwave-js/serial\";",
			"",
			"@messageTypes(MessageType.Request, FunctionType.${1:Dummy})",
			"@priority(MessagePriority.${2:Normal})",
			"export class ${1}RequestBase extends Message {",
			"\tpublic constructor(host: ZWaveHost, options: MessageOptions) {",
			"\t\tif (",
			"\t\t\tgotDeserializationOptions(options) &&",
			"\t\t\t(new.target as any) !== ${1}Callback",
			"\t\t) {",
			"\t\t\treturn new ${1}Callback(host, options);",
			"\t\t}",
			"\t\tsuper(host, options);",
			"\t}",
			"}",
			"",
			"export interface ${1}RequestOptions extends MessageBaseOptions {",
			"\t${0:someProperty: number;}",
			"}",
			"",
			"@expectedResponse(FunctionType.${1})",
			"@expectedCallback(FunctionType.${1})",
			"export class ${1}Request extends ${1}RequestBase {",
			"\tpublic constructor(",
			"\t\thost: ZWaveHost,",
			"\t\toptions: MessageDeserializationOptions | ${1}RequestOptions,",
			"\t) {",
			"\t\tsuper(host, options);",
			"\t\tif (gotDeserializationOptions(options)) {",
			"\t\t\tthrow new ZWaveError(",
			"\t\t\t\t`${this.constructor.name}: deserialization not implemented`,",
			"\t\t\t\tZWaveErrorCodes.Deserialization_NotImplemented,",
			"\t\t\t);",
			"\t\t} else {",
			"\t\t\t// TODO: Populate properties from options object",
			"\t\t\tthrow new Error(\"not implemented\");",
			"\t\t}",
			"\t}",
			"",
			"\tpublic serialize(): Buffer {",
			"\t\tthis.payload = Buffer.from([",
			"\t\t\t/* TODO: serialize */",
			"\t\t\tthis.callbackId,",
			"\t\t]);",
			"",
			"\t\treturn super.serialize();",
			"\t}",
			"",
			"\tpublic toLogEntry(): MessageOrCCLogEntry {",
			"\t\treturn {",
			"\t\t\t...super.toLogEntry(),",
			"\t\t\tmessage: {",
			"\t\t\t\t\"callback id\": this.callbackId,",
			"\t\t\t},",
			"\t\t};",
			"\t}",
			"}",
			"",
			"@messageTypes(MessageType.Response, FunctionType.${1})",
			"export class ${1}Response extends Message {",
			"\tpublic constructor(host: ZWaveHost, options: MessageDeserializationOptions) {",
			"\t\tsuper(host, options);",
			"\t\tthis.wasSent = this.payload[0] !== 0;",
			"\t}",
			"",
			"\tpublic readonly wasSent: boolean;",
			"",
			"\tpublic toLogEntry(): MessageOrCCLogEntry {",
			"\t\treturn {",
			"\t\t\t...super.toLogEntry(),",
			"\t\t\tmessage: { \"was sent\": this.wasSent },",
			"\t\t};",
			"\t}",
			"}",
			"",
			"export class ${1}Callback",
			"\textends ${1}RequestBase",
			"\timplements SuccessIndicator {",
			"\tpublic constructor(host: ZWaveHost, options: MessageDeserializationOptions) {",
			"\t\tsuper(host, options);",
			"",
			"\t\tthis.callbackId = this.payload[0];",
			"\t\tthis.success = this.payload[1] !== 0;",
			"\t}",
			"",
			"\tisOK(): boolean {",
			"\t\treturn this.success;",
			"\t}",
			"",
			"\tpublic readonly success: boolean;",
			"",
			"\tpublic toLogEntry(): MessageOrCCLogEntry {",
			"\t\treturn {",
			"\t\t\t...super.toLogEntry(),",
			"\t\t\tmessage: {",
			"\t\t\t\t\"callback id\": this.callbackId,",
			"\t\t\t\tsuccess: this.success,",
			"\t\t\t},",
			"\t\t};",
			"\t}",
			"}"
		]
	},
	"Z-Wave Serial API command with callback": {
		"scope": "typescript",
		"prefix": "zwmsgcb",
		"body": [
			"import {",
			"\tMessageOrCCLogEntry,",
			"\tMessagePriority,",
			"\tZWaveError,",
			"\tZWaveErrorCodes,",
			"} from \"@zwave-js/core\";",
			"import type { ZWaveApplicationHost, ZWaveHost } from \"@zwave-js/host\";",
			"import {",
			"\tFunctionType,",
			"\tMessageType,",
			"\texpectedCallback,",
			"\tgotDeserializationOptions,",
			"\tMessage,",
			"\tMessageBaseOptions,",
			"\tMessageDeserializationOptions,",
			"\tMessageOptions,",
			"\tmessageTypes,",
			"\tpriority,",
			"\tSuccessIndicator,",
			"} from \"@zwave-js/serial\";",
			"",
			"@messageTypes(MessageType.Request, FunctionType.${1:Dummy})",
			"@priority(MessagePriority.${2:Normal})",
			"export class ${1}RequestBase extends Message {",
			"\tpublic constructor(host: ZWaveHost, options: MessageOptions) {",
			"\t\tif (",
			"\t\t\tgotDeserializationOptions(options) &&",
			"\t\t\t(new.target as any) !== ${1}Callback",
			"\t\t) {",
			"\t\t\treturn new ${1}Callback(host, options);",
			"\t\t}",
			"\t\tsuper(host, options);",
			"\t}",
			"}",
			"",
			"export interface ${1}RequestOptions extends MessageBaseOptions {",
			"\t${0:someProperty: number;}",
			"}",
			"",
			"@expectedCallback(FunctionType.${1})",
			"export class ${1}Request extends ${1}RequestBase {",
			"\tpublic constructor(",
			"\t\thost: ZWaveHost,",
			"\t\toptions: MessageDeserializationOptions | ${1}RequestOptions,",
			"\t) {",
			"\t\tsuper(host, options);",
			"\t\tif (gotDeserializationOptions(options)) {",
			"\t\t\tthrow new ZWaveError(",
			"\t\t\t\t`${this.constructor.name}: deserialization not implemented`,",
			"\t\t\t\tZWaveErrorCodes.Deserialization_NotImplemented,",
			"\t\t\t);",
			"\t\t} else {",
			"\t\t\t// TODO: Populate properties from options object",
			"\t\t\tthrow new Error(\"not implemented\");",
			"\t\t}",
			"\t}",
			"",
			"\tpublic serialize(): Buffer {",
			"\t\tthis.payload = Buffer.from([",
			"\t\t\t/* TODO: serialize */",
			"\t\t\tthis.callbackId,",
			"\t\t]);",
			"",
			"\t\treturn super.serialize();",
			"\t}",
			"",
			"\tpublic toLogEntry(): MessageOrCCLogEntry {",
			"\t\treturn {",
			"\t\t\t...super.toLogEntry(),",
			"\t\t\tmessage: {",
			"\t\t\t\t\"some property\": 1,",
			"\t\t\t},",
			"\t\t};",
			"\t}",
			"}",
			"",
			"export class ${1}Callback",
			"\textends ${1}RequestBase",
			"\timplements SuccessIndicator {",
			"\tpublic constructor(host: ZWaveHost, options: MessageDeserializationOptions) {",
			"\t\tsuper(host, options);",
			"",
			"\t\tthis.callbackId = this.payload[0];",
			"\t\tthis.success = this.payload[1] !== 0;",
			"\t}",
			"",
			"\tisOK(): boolean {",
			"\t\treturn this.success;",
			"\t}",
			"",
			"\tpublic readonly success: boolean;",
			"",
			"\tpublic toLogEntry(): MessageOrCCLogEntry {",
			"\t\treturn {",
			"\t\t\t...super.toLogEntry(),",
			"\t\t\tmessage: {",
			"\t\t\t\t\"callback id\": this.callbackId,",
			"\t\t\t\tsuccess: this.success,",
			"\t\t\t},",
			"\t\t};",
			"\t}",
			"}"
		]
	},
	"Z-Wave Serial API command with subcommands": {
		"scope": "typescript",
		"prefix": "zwmsgsub",
		"body": [
			"import {",
			"\tcreateSimpleReflectionDecorator,",
			"\tMessageOrCCLogEntry,",
			"\tMessagePriority,",
			"\tMessageRecord,",
			"\tvalidatePayload,",
			"\tZWaveError,",
			"\tZWaveErrorCodes,",
			"} from \"@zwave-js/core\";",
			"import type { ZWaveHost } from \"@zwave-js/host\";",
			"import type {",
			"\tDeserializingMessageConstructor,",
			"\tSuccessIndicator,",
			"} from \"@zwave-js/serial\";",
			"import {",
			"\texpectedResponse,",
			"\tFunctionType,",
			"\tgotDeserializationOptions,",
			"\tMessage,",
			"\tMessageBaseOptions,",
			"\tMessageDeserializationOptions,",
			"\tMessageOptions,",
			"\tMessageType,",
			"\tmessageTypes,",
			"\tpriority,",
			"} from \"@zwave-js/serial\";",
			"import { getEnumMemberName } from \"@zwave-js/shared\";",
			"",
			"export enum ${1}Command {",
			"\t${0:SomeCommand} = 0x00,",
			"}",
			"",
			"// We need to define the decorators for Requests and Responses separately",
			"const {",
			"\tdecorator: subCommandRequest,",
			"\t// lookupConstructor: getSubCommandRequestConstructor,",
			"\tlookupValue: getSubCommandForRequest,",
			"} = createSimpleReflectionDecorator<",
			"\t${1}Request,",
			"\t[command: ${1}Command],",
			"\tDeserializingMessageConstructor<${1}Request>",
			">({",
			"\tname: \"subCommandRequest\",",
			"});",
			"",
			"const {",
			"\tdecorator: subCommandResponse,",
			"\tlookupConstructor: getSubCommandResponseConstructor,",
			"} = createSimpleReflectionDecorator<",
			"\t${1}Response,",
			"\t[command: ${1}Command],",
			"\tDeserializingMessageConstructor<${1}Response>",
			">({",
			"\tname: \"subCommandResponse\",",
			"});",
			"",
			"function testResponseFor${1}Request(",
			"\tsent: Message,",
			"\treceived: Message,",
			") {",
			"\tif (!(received instanceof ${1}Response)) return false;",
			"\treturn (sent as ${1}Request).command === received.command;",
			"}",
			"",
			"@messageTypes(MessageType.Request, FunctionType.${1:${TM_FILENAME_BASE/(.*)Messages$/$1/}})",
			"@priority(MessagePriority.${2:Normal})",
			"@expectedResponse(testResponseFor${1}Request)",
			"export class ${1}Request extends Message {",
			"\tpublic constructor(host: ZWaveHost, options: MessageOptions = {}) {",
			"\t\tsuper(host, options);",
			"\t\tif (gotDeserializationOptions(options)) {",
			"\t\t\tthrow new ZWaveError(",
			"\t\t\t\t`${this.constructor.name}: deserialization not implemented`,",
			"\t\t\t\tZWaveErrorCodes.Deserialization_NotImplemented,",
			"\t\t\t);",
			"\t\t} else {",
			"\t\t\tthis.command = getSubCommandForRequest(this)!;",
			"\t\t}",
			"\t}",
			"",
			"\tpublic command: ${1}Command;",
			"",
			"\tpublic serialize(): Buffer {",
			"\t\tthis.payload = Buffer.concat([",
			"\t\t\tBuffer.from([this.command]),",
			"\t\t\tthis.payload,",
			"\t\t]);",
			"",
			"\t\treturn super.serialize();",
			"\t}",
			"",
			"\tpublic toLogEntry(): MessageOrCCLogEntry {",
			"\t\tconst message: MessageRecord = {",
			"\t\t\tcommand: getEnumMemberName(${1}Command, this.command),",
			"\t\t};",
			"\t\tif (this.payload.length > 0) {",
			"\t\t\tmessage.payload = `0x${this.payload.toString(\"hex\")}`;",
			"\t\t}",
			"\t\treturn {",
			"\t\t\t...super.toLogEntry(),",
			"\t\t\tmessage,",
			"\t\t};",
			"\t}",
			"}",
			"",
			"@messageTypes(MessageType.Response, FunctionType.${1})",
			"export class ${1}Response extends Message {",
			"\tpublic constructor(",
			"\t\thost: ZWaveHost,",
			"\t\toptions: MessageDeserializationOptions,",
			"\t) {",
			"\t\tsuper(host, options);",
			"\t\tthis.command = this.payload[0];",
			"",
			"\t\tconst CommandConstructor = getSubCommandResponseConstructor(",
			"\t\t\tthis.command,",
			"\t\t);",
			"\t\tif (CommandConstructor && (new.target as any) !== CommandConstructor) {",
			"\t\t\treturn new CommandConstructor(host, options);",
			"\t\t}",
			"",
			"\t\tthis.payload = this.payload.slice(1);",
			"\t}",
			"",
			"\tpublic command: ${1}Command;",
			"",
			"\tpublic toLogEntry(): MessageOrCCLogEntry {",
			"\t\tconst message: MessageRecord = {",
			"\t\t\tcommand: getEnumMemberName(${1}Command, this.command),",
			"\t\t};",
			"\t\tif (this.payload.length > 0) {",
			"\t\t\tmessage.payload = `0x${this.payload.toString(\"hex\")}`;",
			"\t\t}",
			"\t\treturn {",
			"\t\t\t...super.toLogEntry(),",
			"\t\t\tmessage,",
			"\t\t};",
			"\t}",
			"}"
		]
	},
	"Z-Wave Serial API subcommand with response": {
		"scope": "typescript",
		"prefix": "zwmsgsubres",
		"body": [
			"// =============================================================================",
			"",
			"export interface ${1:${TM_FILENAME_BASE/(.*)Messages$/$1/}}_${2:SomeCommand}RequestOptions extends MessageBaseOptions {",
			"\t${0:someProperty: number;}",
			"}",
			"",
			"@subCommandRequest(${1}Command.${2})",
			"export class ${1}_${2}Request extends ${1}Request {",
			"\tpublic constructor(",
			"\t\thost: ZWaveHost,",
			"\t\toptions:",
			"\t\t\t| MessageDeserializationOptions",
			"\t\t\t| ${1}_${2}RequestOptions,",
			"\t) {",
			"\t\tsuper(host, options);",
			"\t\tthis.command = ${1}Command.${2};",
			"",
			"\t\tif (gotDeserializationOptions(options)) {",
			"\t\t\tthrow new ZWaveError(",
			"\t\t\t\t`${this.constructor.name}: deserialization not implemented`,",
			"\t\t\t\tZWaveErrorCodes.Deserialization_NotImplemented,",
			"\t\t\t);",
			"\t\t} else {",
			"\t\t\t// TODO: Populate properties from options object",
			"\t\t\tthrow new Error(\"not implemented\");",
			"\t\t}",
			"\t}",
			"",
			"\tpublic serialize(): Buffer {",
			"\t\tthis.payload = Buffer.from([",
			"\t\t\t/* TODO: serialize */",
			"\t\t]);",
			"",
			"\t\treturn super.serialize();",
			"\t}",
			"",
			"\tpublic toLogEntry(): MessageOrCCLogEntry {",
			"\t\tconst ret = { ...super.toLogEntry() };",
			"\t\tconst message = ret.message!;",
			"\t\t/* TODO: Set log message properties */",
			"\t\tdelete message.payload;",
			"\t\treturn ret;",
			"\t}",
			"}",
			"",
			"@subCommandResponse(${1}Command.${2})",
			"export class ${1}_${2}Response extends ${1}Response",
			"{",
			"\tpublic constructor(",
			"\t\thost: ZWaveHost,",
			"\t\toptions: MessageDeserializationOptions,",
			"\t) {",
			"\t\tsuper(host, options);",
			"\t\tthis.wasSent = this.payload[0] !== 0;",
			"\t}",
			"",
			"\tpublic readonly wasSent: boolean;",
			"",
			"\tpublic toLogEntry(): MessageOrCCLogEntry {",
			"\t\tconst ret = { ...super.toLogEntry() };",
			"\t\tconst message = ret.message!;",
			"\t\tmessage[\"was sent\"] = this.wasSent;",
			"\t\tdelete message.payload;",
			"\t\treturn ret;",
			"\t}",
			"}"
		]
	},
	"Z-Wave Serial API subcommand with response (empty request)": {
		"scope": "typescript",
		"prefix": "zwmsgemptysubres",
		"body": [
			"// =============================================================================",
			"",
			"@subCommandRequest(${1:${TM_FILENAME_BASE/(.*)Messages$/$1/}}Command.${2:SomeCommand})",
			"export class ${1}_${2}Request extends ${1}Request {}",
			"",
			"@subCommandResponse(${1}Command.${2})",
			"export class ${1}_${2}Response extends ${1}Response",
			"{",
			"\tpublic constructor(",
			"\t\thost: ZWaveHost,",
			"\t\toptions: MessageDeserializationOptions,",
			"\t) {",
			"\t\tsuper(host, options);",
			"\t\tthis.wasSent = this.payload[0] !== 0;",
			"\t}",
			"",
			"\tpublic readonly wasSent: boolean;",
			"",
			"\tpublic toLogEntry(): MessageOrCCLogEntry {",
			"\t\tconst ret = { ...super.toLogEntry() };",
			"\t\tconst message = ret.message!;",
			"\t\tmessage[\"was sent\"] = this.wasSent;",
			"\t\tdelete message.payload;",
			"\t\treturn ret;",
			"\t}",
			"}"
		]
	},
	"Z-Wave Command Class log override": {
		"scope": "typescript",
		"prefix": "zwcclog",
		"body": [
			"public toLogEntry(applHost: ZWaveApplicationHost): MessageOrCCLogEntry {",
			"\treturn {",
			"\t\t...super.toLogEntry(applHost),",
			"\t\tmessage: { ${1:someProp}: this.${1} },",
			"\t};",
			"}"
		]
	},
	"Z-Wave Command Class log override (empty)": {
		"scope": "typescript",
		"prefix": "zwcclogempty",
		"body": [
			"public toLogEntry(applHost: ZWaveApplicationHost): MessageOrCCLogEntry {",
			"\treturn {",
			"\t\t...super.toLogEntry(applHost),",
			"\t\t// Hide the default payload line",
			"\t\tmessage: undefined,",
			"\t};",
			"}"
		]
	},
	"Z-Wave Command Class persistValues override": {
		"scope": "typescript",
		"prefix": "zwccpv",
		"body": [
			"public persistValues(applHost: ZWaveApplicationHost): boolean {",
			"\tif (!super.persistValues(applHost)) return false;",
			"\tconst valueDB = this.getValueDB(applHost);",
			"",
			"\t${0://TODO: Implementation}",
			"",
			"\treturn true;",
			"}"
		]
	},
	"Z-Wave Command Class implementation": {
		"scope": "typescript",
		"prefix": "zwcc",
		"body": [
			"import {",
			"\tCommandClass,",
			"\tgotDeserializationOptions,",
			"\ttype CCCommandOptions,",
			"\ttype CommandClassDeserializationOptions,",
			"} from \"../lib/CommandClass\";",
			"import {",
			"\tCCCommand,",
			"\tccValue,",
			"\tccValues,",
			"\tcommandClass,",
			"\texpectedCCResponse,",
			"\timplementedVersion,",
			"} from \"../lib/CommandClassDecorators\";",
			"import {",
			"\tCommandClasses,",
			"\tMessageOrCCLogEntry,",
			"\tMessagePriority,",
			"\tZWaveError,",
			"\tZWaveErrorCodes,",
			"} from \"@zwave-js/core\";",
			"import type { ZWaveApplicationHost, ZWaveHost } from \"@zwave-js/host\";",
			"import { CCAPI } from \"../lib/API\";",
			"",
			"// TODO: Move this enumeration into the src/lib/_Types.ts file",
			"// All additional type definitions (except CC constructor options) must be defined there too",
			"export enum ${1:${TM_FILENAME_BASE/(.*)CC$/$1/}}Command {",
			"\t${3:// Get = 0x01}",
			"}",
			"",
			"@commandClass(CommandClasses.${1})",
			"@implementedVersion(${2:1})",
			"@ccValues(${1}CCValues)",
			"export class ${1}CC extends CommandClass {",
			"\tdeclare ccCommand: ${1}Command;",
			"}",
			"",
			"${0}"
		],
		"description": "Z-Wave Command Class implementation"
	},
	"Z-Wave CC Values": {
		"scope": "typescript",
		"prefix": "zwccvalues",
		"body": [
			"export const ${1:${TM_FILENAME_BASE/(.*)CC$/$1/}}CCValues = Object.freeze({",
			"\t...V${0}.defineStaticCCValues(CommandClasses.${2:${TM_FILENAME_BASE/(.*)CC$/$1/}}, {",
			"\t\t// Static CC values go here",
			"\t}),",
			"",
			"\t...V.defineDynamicCCValues(CommandClasses.${2}, {",
			"\t\t// Dynamic CC values go here",
			"\t}),",
			"});",
			""
		],
		"description": "Z-Wave Command Class values definition"
	},
	"Z-Wave CC Value (static, property only)": {
		"scope": "typescript",
		"prefix": "zwccvaluestatic",
		"body": [
			"...V.staticProperty(",
			"\t\"${1:property}\",",
			"\t${2:// undefined, // meta}",
			"\t${3:// { internal: true \\}, // value options}",
			"),"
		],
		"description": "Static CC value"
	},
	"Z-Wave CC Value (static, named property)": {
		"scope": "typescript",
		"prefix": "zwccvaluestaticname",
		"body": [
			"...V.staticPropertyWithName(",
			"\t\"${1:valueName}\",",
			"\t\"${2:property}\",",
			"\t${3:// undefined, // meta}",
			"\t${4:// { internal: true \\}, // value options}",
			"),"
		],
		"description": "Static CC value with name"
	},
	"Z-Wave CC Value (static, named, property & key)": {
		"scope": "typescript",
		"prefix": "zwccvaluestaticpropkey",
		"body": [
			"...V.staticPropertyAndKeyWithName(",
			"\t\"${1:valueName}\",",
			"\t\"${2:property}\",",
			"\t\"${3:propertyKey}\",",
			"\t${4:// undefined, // meta}",
			"\t${5:// { internal: true \\}, // value options}",
			"),"
		],
		"description": "Static CC value with name, property and propertyKey"
	},
	"Z-Wave CC Value (dynamic, named property)": {
		"scope": "typescript",
		"prefix": "zwccvaluedynamicname",
		"body": [
			"...V.dynamicPropertyWithName(",
			"\t\"${1:valueName}\",",
			"\t(${2:arg1}: ${3:number}) => ${0:${2}},",
			"\t({ property }) => typeof property === \"${3}\",",
			"\t// (${2}: ${3}) => ({ ...ValueMetadata.Any }), // meta, can also be a static value",
			"\t// (${2}: ${3}) => ({ internal: true }), // value options, can also be a static value",
			"),"
		],
		"description": "Dynamic CC value with name"
	},
	"Z-Wave CC Value (dynamic, named, property & key)": {
		"scope": "typescript",
		"prefix": "zwccvaluedynamicpropkey",
		"body": [
			"...V.dynamicPropertyAndKeyWithName(",
			"\t\"${1:valueName}\",",
			"\t\"${1}\",",
			"\t(${2:arg1}: ${3:number}) => ${0:${2}},",
			"\t({ property, propertyKey }) => property === \"${1}\",",
			"\t// (${2}: ${3}) => ({ ...ValueMetadata.Any }), // meta, can also be a static value",
			"\t// (${2}: ${3}) => ({ internal: true }), // value options, can also be a static value",
			"),"
		],
		"description": "Dynamic CC value with name, property and propertyKey"
	},
	"Z-Wave CC Command": {
		"scope": "typescript",
		"prefix": "zwcccmd",
		"body": [
			"interface ${1:${TM_FILENAME_BASE/(.*)CC$/$1/}}CC${2:Get}Options extends CCCommandOptions {",
			"\tsomeProperty: number;",
			"}",
			"",
			"@CCCommand(${1}Command.${2})",
			"@expectedCCResponse(${1}CCReport)",
			"export class ${1}CC${2} extends ${1}CC {",
			"\tpublic constructor(",
			"\t\thost: ZWaveHost,",
			"\t\toptions: CommandClassDeserializationOptions | ${1}CC${2}Options,",
			"\t) {",
			"\t\tsuper(host, options);",
			"\t\tif (gotDeserializationOptions(options)) {",
			"\t\t\t// TODO: Deserialize payload",
			"\t\t\tthrow new ZWaveError(",
			"\t\t\t\t`${this.constructor.name}: deserialization not implemented`,",
			"\t\t\t\tZWaveErrorCodes.Deserialization_NotImplemented,",
			"\t\t\t);",
			"\t\t} else {",
			"\t\t\t// TODO: Populate properties from options object",
			"\t\t\tthrow new Error(\"not implemented\");",
			"\t\t}",
			"\t}",
			"",
			"\tpublic serialize(): Buffer {",
			"\t\tthis.payload = Buffer.from([",
			"\t\t\t/* TODO: serialize */",
			"\t\t]);",
			"\t\treturn super.serialize();",
			"\t}",
			"}",
			"${0}"
		],
		"description": "Specific implementation of a single CC command"
	},
	"Z-Wave CC Command (Report)": {
		"scope": "typescript",
		"prefix": "zwccreport",
		"body": [
			"@CCCommand(${1:${TM_FILENAME_BASE/(.*)CC$/$1/}}Command.${2}Report)",
			"export class ${1}CC${2}Report extends ${1}CC {",
			"\tpublic constructor(",
			"\t\thost: ZWaveHost,",
			"\t\toptions: CommandClassDeserializationOptions,",
			"\t) {",
			"\t\tsuper(host, options);",
			"\t\t${0:// TODO: Deserialize}",
			"\t}",
			"}"
		],
		"description": "Specific implementation of a single CC report"
	},
	"ZWave CC Command (empty)": {
		"scope": "typescript",
		"prefix": "zwccemptycmd",
		"body": [
			"@CCCommand(${1:${TM_FILENAME_BASE/(.*)CC$/$1/}}Command.${2:Get})",
			"export class ${1}CC${2} extends ${1}CC {}"
		],
		"description": "Specific implementation of CC command that is sent and expects no parameters"
	},
	"ZWave CC Get Command (empty)": {
		"scope": "typescript",
		"prefix": "zwccemptyget",
		"body": [
			"@CCCommand(${1:${TM_FILENAME_BASE/(.*)CC$/$1/}}Command.${2}Get)",
			"@expectedCCResponse(${1}CC${2}Report)",
			"export class ${1}CC${2}Get extends ${1}CC {}"
		],
		"description": "Specific implementation of a CC Get command that expects no parameters"
	},
	"ZWave test CC response implementation": {
		"scope": "typescript",
		"prefix": "zwcctestresponse",
		"body": [
			"function testResponseFor${1:${TM_FILENAME_BASE/(.*)CC$/$1/}}${2}Get(",
			"\tsent: ${1}CC${2}Get,",
			"\treceived: ${1}CC${2}Report,",
			") {",
			"\treturn received.${3:type} === sent.${3};",
			"}"
		],
		"description": "Tests if a received message belongs to this Get-type command"
	},
	"Readonly property": {
		"scope": "typescript",
		"prefix": "propread",
		"body": [
			"private _${1:value}: ${2:string};",
			"public get ${1}(): ${2} {",
			"\treturn this._${1};",
			"}${0}"
		]
	},
	"Z-Wave CC property": {
		"scope": "typescript",
		"prefix": "zwccprop",
		"body": ["@ccValue() public ${1:property}: ${2:number};${0}"]
	},
	"Z-Wave CC API": {
		"scope": "typescript",
		"prefix": "zwccapi",
		"body": [
			"@API(CommandClasses.${1:${TM_FILENAME_BASE/(.*)CC$/$1/}})",
			"export class ${1}CCAPI extends CCAPI {",
			"\t${0:// TODO: Implementation}",
			"}"
		]
	},
	"Z-Wave CC supportsCommand": {
		"scope": "typescript",
		"prefix": "zwccsupp",
		"body": [
			"public supportsCommand(cmd: ${1:${TM_FILENAME_BASE/(.*)CC$/$1/}}Command): Maybe<boolean> {",
			"\tswitch (cmd) {",
			"\t\tcase ${1}Command.Get:",
			"\t\tcase ${1}Command.Set:",
			"\t\t\treturn true; // This is mandatory",
			"\t\t// case ${1}Command.SomeV2Command:",
			"\t\t// \treturn this.version >= 2;",
			"\t}",
			"\treturn super.supportsCommand(cmd);",
			"}",
			""
		],
		"description": "Implementation of CCAPI.supportsCommand"
	},
	"Z-Wave CC API assert command supported": {
		"scope": "typescript",
		"prefix": "zwccassert",
		"body": [
			"this.assertSupportsCommand(",
			"\t${1:${TM_FILENAME_BASE/(.*)CC$/$1/}}Command,",
			"\t${1}Command.${2:Get},",
			");",
			""
		],
		"description": "Implementation of CCAPI.supportsCommand"
	},
	"Z-Wave CC interview procedure": {
		"scope": "typescript",
		"prefix": "zwccinterview",
		"body": [
			"public async interview(applHost: ZWaveApplicationHost): Promise<void> {",
			"\tconst node = this.getNode(applHost)!;",
			"\tconst endpoint = this.getEndpoint(applHost)!;",
			"\tconst api = CCAPI.create(",
			"\t\tCommandClasses.${1:${TM_FILENAME_BASE/(.*)CC$/$1/}},",
			"\t\tapplHost,",
			"\t\tendpoint",
			"\t).withOptions({",
			"\t\tpriority: MessagePriority.NodeQuery,",
			"\t});",
			"\tconst valueDB = this.getValueDB(applHost);",
			"",
			"\tapplHost.controllerLog.logNode(node.id, {",
			"\t\tendpoint: this.endpointIndex,",
			"\t\tmessage: `Interviewing ${this.ccName}...`,",
			"\t\tdirection: \"none\",",
			"\t});",
			"",
			"\tapplHost.controllerLog.logNode(node.id, {",
			"\t\tendpoint: this.endpointIndex,",
			"\t\tmessage: \"doing something...\",",
			"\t\tdirection: \"outbound\",",
			"\t});",
			"\t${0:// TODO: Implementation}",
			"\tconst logMessage = `received response for something...`;",
			"\tapplHost.controllerLog.logNode(node.id, {",
			"\t\tendpoint: this.endpointIndex,",
			"\t\tmessage: logMessage,",
			"\t\tdirection: \"inbound\",",
			"\t});",
			"",
			"\t// Remember that the interview is complete",
			"\tthis.setInterviewComplete(applHost, true);",
			"}"
		]
	},
	"Z-Wave CC interview requirements": {
		"scope": "typescript",
		"prefix": "zwccintreq",
		"body": [
			"public determineRequiredCCInterviews(): readonly CommandClasses[] {",
			"\treturn [",
			"\t\t...super.determineRequiredCCInterviews(),",
			"\t\tCommandClasses.${0:${TM_FILENAME_BASE/(.*)CC$/$1/}},",
			"\t];",
			"}"
		]
	},
	"Z-Wave CC Refresh Values": {
		"scope": "typescript",
		"prefix": "zwccrefval",
		"body": [
			"public async refreshValues(applHost: ZWaveApplicationHost): Promise<void> {",
			"\tconst node = this.getNode(applHost)!;",
			"\tconst endpoint = this.getEndpoint(applHost)!;",
			"\tconst api = CCAPI.create(",
			"\t\tCommandClasses.${1:${TM_FILENAME_BASE/(.*)CC$/$1/}},",
			"\t\tapplHost,",
			"\t\tendpoint",
			"\t).withOptions({",
			"\t\tpriority: MessagePriority.NodeQuery,",
			"\t});",
			"\tconst valueDB = this.getValueDB(applHost);",
			"",
			"\t${0:// TODO: Implementation}",
			"}"
		]
	},
	"Z-Wave CC Test": {
		"scope": "typescript",
		"prefix": "zwcctest",
		"body": [
			"import { createEmptyMockDriver } from \"../test/mocks\";",
			"import type { Driver } from \"../driver/Driver\";",
			"import {",
			"\t${1}CC,",
			"\t${1}CCGet,",
			"\t${1}CCReport,",
			"\t${1}CCSet,",
			"\t${1}Command,",
			"} from \"./${1}CC\";",
			"import { getCCValueMetadata } from \"./CommandClass\";",
			"import { CommandClasses } from \"@zwave-js/core\";",
			"",
			"const fakeDriver = (createEmptyMockDriver() as unknown) as Driver;",
			"",
			"function buildCCBuffer(payload: Buffer): Buffer {",
			"\treturn Buffer.concat([",
			"\t\tBuffer.from([",
			"\t\t\tCommandClasses.${1}, // CC",
			"\t\t]),",
			"\t\tpayload,",
			"\t]);",
			"}",
			"",
			"describe(\"lib/commandclass/${1:${TM_FILENAME_BASE/(.*)CC$/$1/}}CC => \", () => {",
			"\tit(\"the Get command should serialize correctly\", () => {",
			"\t\tconst cc = new ${1}CCGet(fakeDriver, { nodeId: 1 });",
			"\t\tconst expected = buildCCBuffer(",
			"\t\t\tBuffer.from([",
			"\t\t\t\t${1}Command.Get, // CC Command",
			"\t\t\t]),",
			"\t\t);",
			"\t\texpect(cc.serialize()).toEqual(expected);",
			"\t});",
			"",
			"\tit(\"the Set command should serialize correctly\", () => {",
			"\t\tconst cc = new ${1}CCSet(fakeDriver, {",
			"\t\t\tnodeId: 2,",
			"\t\t\ttargetValue: 55,",
			"\t\t});",
			"\t\tconst expected = buildCCBuffer(",
			"\t\t\tBuffer.from([",
			"\t\t\t\t${1}Command.Set, // CC Command",
			"\t\t\t\t55, // target value",
			"\t\t\t]),",
			"\t\t);",
			"\t\texpect(cc.serialize()).toEqual(expected);",
			"\t});",
			"",
			"\tit(\"the Report command (v1) should be deserialized correctly\", () => {",
			"\t\tconst ccData = buildCCBuffer(",
			"\t\t\tBuffer.from([",
			"\t\t\t\t${1}Command.Report, // CC Command",
			"\t\t\t\t55, // current value",
			"\t\t\t]),",
			"\t\t);",
			"\t\tconst cc = new ${1}CCReport(fakeDriver, { data: ccData });",
			"",
			"\t\texpect(cc.currentValue).toBe(55);",
			"\t\texpect(cc.targetValue).toBeUndefined();",
			"\t\texpect(cc.duration).toBeUndefined();",
			"\t});",
			"",
			"\tit(\"the Report command (v2) should be deserialized correctly\", () => {",
			"\t\tconst ccData = buildCCBuffer(",
			"\t\t\tBuffer.from([",
			"\t\t\t\t${1}Command.Report, // CC Command",
			"\t\t\t\t55, // current value",
			"\t\t\t\t66, // target value",
			"\t\t\t\t1, // duration",
			"\t\t\t]),",
			"\t\t);",
			"\t\tconst cc = new ${1}CCReport(fakeDriver, { data: ccData });",
			"",
			"\t\texpect(cc.currentValue).toBe(55);",
			"\t\texpect(cc.targetValue).toBe(66);",
			"\t\texpect(cc.duration!.unit).toBe(\"seconds\");",
			"\t\texpect(cc.duration!.value).toBe(1);",
			"\t});",
			"",
			"\tit(\"deserializing an unsupported command should return an unspecified version of ${1}CC\", () => {",
			"\t\tconst serializedCC = buildCCBuffer(",
			"\t\t\t1,",
			"\t\t\tBuffer.from([255]), // not a valid command",
			"\t\t);",
			"\t\tconst cc: any = new ${1}CC(fakeDriver, {",
			"\t\t\tdata: serializedCC,",
			"\t\t});",
			"\t\texpect(cc.constructor).toBe(${1}CC);",
			"\t});",
			"",
			"\tit(\"the CC values should have the correct metadata\", () => {",
			"\t\t// Readonly, 0-99",
			"\t\tconst currentValueMeta = getCCValueMetadata(",
			"\t\t\tCommandClasses.${1},",
			"\t\t\t\"currentValue\",",
			"\t\t);",
			"\t\texpect(currentValueMeta).toMatchObject({",
			"\t\t\treadable: true,",
			"\t\t\twriteable: false,",
			"\t\t\tmin: 0,",
			"\t\t\tmax: 99,",
			"\t\t});",
			"",
			"\t\t// Writeable, 0-99",
			"\t\tconst targetValueMeta = getCCValueMetadata(",
			"\t\t\tCommandClasses.${1},",
			"\t\t\t\"targetValue\",",
			"\t\t);",
			"\t\texpect(targetValueMeta).toMatchObject({",
			"\t\t\treadable: true,",
			"\t\t\twriteable: true,",
			"\t\t\tmin: 0,",
			"\t\t\tmax: 99,",
			"\t\t});",
			"\t});",
			"});",
			""
		],
		"description": "Specific implementation of a single CC command"
	}
}
